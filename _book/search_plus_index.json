{"./":{"url":"./","title":"Computer Network 1","keywords":"","body":"Introduction SE370 Computer Network 1 "},"0 Intro/Intro.html":{"url":"0 Intro/Intro.html","title":"Introduction","keywords":"","body":"0. Introduction Architecture(逻辑层面) Layers：网络之间进行分层 Protocols：描述同一层次的关系 Services：描述垂直的关系，下层为上层提供服务 每层的数据单元： Application Layer： massage Transport Layer： segment Network Layer： package Link Layer： frame Physical Layer: bit Internet Structure(物理层面) Network edge Host: takes application message, breaks into packets and transmit them Server: Access network (包括家庭网络和大学网络)：• residential • institutional • mobile Network core Packet forwarding Functions: routing （global 通过forwarding table 计算下步的接口）, forwarding（local 在这个路由中switching对应的接口） Packet Switching vs Circuit Switching Packet Switching ：将长报文划分为较小的数据块（现在网络在用使用的方式）（不需要预定，但不保证） 特点：Store and forward：在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接受到整个分组。 Circuit Switching： 预留了通信所需要的资源（需要预定） 方式： FDM：划分不同的频率 TDM：划分不同的时间段 Internet Structure: Global View At “center”: small # of well-connected large networks “tier-1” commercial ISPs (e.g., Level 3, Sprint, AT&T, NTT)： national & international coverage content provider networks (e.g., Google, Facebook): private network that connects its data centers to Internet, often bypassing tier-1, regional ISPs Performance Metrics Packet loss（无线网络中损失较大， 路由排队时也会出现丢包） Throughput（实际值） =》 bandwidth（理论值） Packet delay ​ d(proc)(处理时延)：决定该分组导向何处所需的时间；检查比特级别的差错；流量控制 ​ d(queue)(排队时延)： 在队列中排队所花费的时间 ​ d(trans)(传输时延)：路由器推出分组所需要的时间 => 包的大小 ​ d(prop)(传播时延)： 从一台路由到另一台所需的时间 => 传播物理特性 "},"1 Application Layer/Application Layer.html":{"url":"1 Application Layer/Application Layer.html","title":"Application Layer","keywords":"","body":"Application Layer Two predominant architectural paradigms(体系结构) Client-Server paradigm: Web, Email, Streaming, Messaging, Interactive games Peer-Peer paradigm: P2P file sharing The Interface Between the Process and the Computer Network process sends/receives messages to/from its socket identifier = To send HTTP message to gaia.cs.umass.edu web server: IP address: 128.119.245.12 port number: 80 Web: HTML Web page: consists of objects, each can be stored on different Web servers object can be HTML file, JPEG image, Java applet, audio file,… each object is addressable by a URL, e.g., Basics of HTTP Four steps using TCP 发起一个与服务器的TCP连接 通过TCP发送HTTP请求 通过TCP收到HTTP相应 断开TCP连接 HTTP is stateless HTTP服务器并不保存关于客户的任何信息 -> stateless ex; If a particular client asks for the same object twice in a period of a few seconds, the server does not respond by saying that it just served the object to the client; instead, the server resends the object, as it has completely forgotten what it did earlier Non-persistent/Persistent HTTP (1.1) Non-persistent: 每个请求/响应对是经过一个单独的TCP连接发起的 Persistent：每个请求/响应对是经过相同的TCP连接发起的（HTTP 1.1 使用） RTT (Round-Trip Time)(往返时间)：The time it takes for a small packet to travel from client to server and then back to the client. The RTT includes packet-propagation delays, packetqueuing delays in intermediate routers and switches, and packet-processing delays. HTTP request message Two types of HTTP messages: request, response HTTP request message: ASCII (human-readable format) HTTP request message: general format Other HTTP request messages POST method: web page often includes form input user input sent from client to server in entity body of HTTP POST request message，Get的通常为空的 用户提交表单 Web页面的特定内容依赖于用户在表单输入的内容，Web的页面请求 GET method: Include user data in URL field of HTTP GET request message (following a ‘?’)，所请求的URL中包括输入的数据: HEAD method: Requests headers (only) that would be returned if specified URL were requested with an HTTP GET method. 服务器收到HEAD请求时，会返回一个HTTP响应，但不返回请求对象 常用来调试跟踪 PUT method: uploads new file (object) to server completely replaces file that exists at specified URL with content in entity body of POST HTTP request message HTTP response message HTTP response status codes status code appears in 1st line in server-to-client response message. some sample codes: 200 OK request succeeded, requested object later in this message 301 Moved Permanently requested object moved, new location specified later in this message (in Location: field) 400 Bad Request request msg not understood by server 404 Not Found requested document not found on this server 505 HTTP Version Not Supported HTTP: Advanced Issues Cookies Purpose: to solve the stateless issue Four components A cookie header line in the HTTP response message A cookie header line in the HTTP request message A cookie file kept on the user’s end system and managed by the user’s browser A back-end database at the Web site Web caches Purpose: satisfy client requests without involving origin server(保存最近请求过的对象的副本) Also known as proxy server Conditional Get: If-modified-since: , HTTP/1.0 304 Not Modified proxy cache代表一个请求浏览器，向Web服务器发送请求报文： Web服务器向缓存器发送具有被请求的对象的响应报文： 一星期后对象仍储存在本地，再向其发送请求报文，询问对象是否被修改（日期为一星期前访问的日期） 如果没有修改，则返回无entity的报文，否则更新 Email, SMTP, IMAP Three major components： user agents, mail servers, SMTP protocol SMTP procedure Alice invokes her user agent for e-mail, provides Bob’s e-mail address (for example, bob@someschool.edu), composes a message, and instructs the user agent to send the message. Alice’s user agent sends the message to her mail server, where it is placed in a message queue. The client side of SMTP, running on Alice’s mail server, sees the message in the message queue. It opens a TCP connection to an SMTP server, running on Bob’s mail server. After some initial SMTP handshaking, the SMTP client sends Alice’s message into the TCP connection. At Bob’s mail server, the server side of SMTP receives the message. Bob’s mail server then places the message in Bob’s mailbox. Bob invokes his user agent to read the message at his convenience. client STMP => server STMP Open a TCP connection SMTP handshaking SMTP transfer of messages SMTP closure Comparison with HTTP Different HTTP: client pull SMTP: client push HTTP: each object encapsulated in its own response message(对象可能存储在不同的主机上) SMTP: multiple objects sent in multipart message（在同一主机） Same Both have ASCII command/response interaction, status codes Domain Name System (DNS) Application-layer protocol： hosts, DNS servers communicate to resolve names (hostname-to-IP-address translation)；core Internet function Distributed database： implemented in hierarchy of many name servers Iterated query（迭代查询）: Recursive query（递归查询）: 实践中请求主机到本地DNS服务器的查询是递归的，其余的是迭代的 DNS records Type=A: Name is a hostname, Value is the IP address for the hostname. Thus, a Type A record provides the standard hostname-to-IP address mapping. As an example, (relay1.bar.foo.com, 145.37.93.126, A) is a Type A record. Type=NS: Name is a domain (such as foo.com), Value is the hostname of an authoritative DNS server that knows how to obtain the IP addresses for hosts in the domain. This record is used to route DNS queries further along in the query chain. As an example, (foo.com, dns.foo.com, NS) is a Type NS record. Value是获得该域主机IP地址的权威DNS服务器的主机名 Type=CNAME: Value is a canonical hostname for the alias hostname Name. This record can provide querying hosts the canonical name for a hostname. As an example, (foo.com, relay1.bar.foo.com, CNAME) is a CNAME record. Value是别名为Name 的主机对应的规范主机名 Type=MX: then Value is the canonical name of a mail server that has an alias hostname Name. As an example, (foo.com, mail.bar.foo.com, MX) is an MX record. MX records allow the hostnames of mail servers to have simple aliases. Note that by using the MX record, a company can have the same aliased name for its mail server and for one of its other servers (such as its Web server). To obtain the canonical name for the mail server, a DNS client would query for an MX record; to obtain the canonical name for the other server, the DNS client would query for the CNAME record. Value是别名为Name 的邮件服务器对应的规范主机名 "},"2 Transport Layer/Transport Layer.html":{"url":"2 Transport Layer/Transport Layer.html","title":"Transport Layer","keywords":"","body":"Transport Layer Provide logical communication between app processes running on different hosts Transport protocols actions in end systems: sender: breaks application messages into segments, passes to network layer receiver: reassembles segments into messages, passes to application layer Two transport protocols: TCP, UDP Transport layer vs Network layer Network: logical communication between hosts Transport: logical communication between processes Demultiplexing(多路分解) Demultiplexing：将运输层报文段中的数据交付到正确的Socket Multiplexing：源主机收集数据，并按上头部信息从而生成报文段 Connectionless 如果两个UDP报文段有不同的源IP地址或/和源端口号，那么这两个报文将通过相同的目的Socket被指定到相同的目的进程 Connection-oriented Three segments, all destined to IP address: B, dest port: 80 are demultiplexed to different sockets UDP: User Datagram Protocol UDP Segment Structure UDP Checksum 对报文中的所有比特字的和进行反码运算（异或运算），如有任何溢出都被回卷，若无改变最后结果应为：1111111111111 Principles of Reliable Data Transfer (RDT) 通过上层协议可靠使得下层的数据传输变得可靠 rdt 1.0: underlying channel perfectly reliable 假设底层信道是完全可靠的 rdt 2.0: channel with bit errors (corrputed packet) 底层信道在分组中的比特可能受损 如果没有差错发送ACK，否则发送 NAK rdt 2.1: handling duplicates 解决ACK和NAK受损的情况 ->2.0 发送方重发当前的数据分组->2.1处理这些重发的数据分组 在数据分组中，添加新的字段，使发送方对其数据分组进行编号（sequence number），接收方通过检查序号确定是否是在重传 rdt 2.2: NAK-free (receiver ACK with seq#) 接收方发送ACK时也要有编号 rdt 3.0: packet loss (timeout) 解决发送方不知道是数据分组丢失，ACK丢失，还是过度延迟 Pipelined rdt 解决丢失，损坏及延时过大分组的方式 Go-Back-N (GBN) 如果超时，发送方重传所有已发但未被确认的分组 Selective Repeat (SR) 在接受方加一个缓存，用来存储未收到数据后边的数据 TCP(Transmission Control Protocol) point-to-point: one sender, one receiver reliable, in-order byte steam: no “message boundaries\" full duplex data: bi-directional data flow in same connection; MSS: maximum segment size cumulative ACKs pipelining: TCP congestion and flow control set window size connection-oriented: 3-way handshaking flow controlled: sender will not overwhelm receiver TCP Segment Structure Sequence number: 用来实现可靠数据传输服务 ACK number：下一个应传的byte rwnd：用于流量控制 TCP Sender and Receiver 往返时间的估计与超时 大多数TCP仅对某个时刻做一次SampleRTT测量 （$\\alpha$ 推荐值为0.125） DevRTT用于估算SampleRTT偏离EstimatedRTT的程度，波动越小，其值越小（$\\beta$ 推荐值是0.25） TimeoutInterval TCP Retransmission Scenarios The acknowledgment from B to A gets lost: In this case, the timeout event occurs, and Host A retransmits the same segment. Of course, when Host B receives the retransmission, it observes from the sequence number that the segment contains data that has already been received. Thus, TCP in Host B will discard the bytes in the retransmitted segment. Neither of the acknowledgments arrives at Host A before the timeout :When the timeout event occurs, Host A resends the first segment with sequence number 92 and restarts the timer. As long as the ACK for the second segment arrives before the new timeout, the second segment will not be retransmitted. The acknowledgment of the first segment is lost in the network, but just before the timeout event, Host A receives an acknowledgment with acknowledgment number 120. Host A therefore knows that Host B has received everything up through byte 119; so Host A does not resend either of the two segments. Fast retransmit When a segment is lost, this long timeout period forces the sender to delay resending the lost packet, thereby increasing the end-to-end delay. Duplicate ACK : an ACK that reacknowledges a segment for which the sender has already received an earlier acknowledgment. Three duplicate ACKs are received, the TCP sender performs a fast retransmit Selective acknowledgment: allows a TCP receiver to acknowledge out-of-order segments selectively rather than just cumulatively acknowledging the last correctly received, in-order segment. TCP ’s error-recovery mechanism is probably best categorized as a hybrid of GBN and SR protocols. Flow Control[接收端把内容太多] rwnd field TCP receiver “advertises” free buffer space in rwnd field in TCP header Sender limits amount of unACKed (“in-flight”) data to received rwnd TCP Connection Management Open a connection ​ Problems with 2-way handshake ​ ​ 3-way handshake The client-side TCP first sends a special TCP segment to the server-side TCP. This special segment contains no application-layer data. But one of the flag bits in the segment’s header , the SYN bit, is set to 1. For this reason, this special segment is referred to as a SYN segment Once the IP datagram containing the TCP SYN segment arrives at the server host (assuming it does arrive!), the server extracts the TCP SYN segment from the datagram, allocates the TCP buffers and variables to the connection, and sends a connection-granted segment to the client TCP. The connection-granted segment is referred to as a SYNACK segment. Upon receiving the SYNACK segment, the client also allocates buffers and variables to the connection. The client host then sends the server yet another segment; The SYN bit is set to zero, since the connection is established. This third stage of the three-way handshake may carry client-toserver data in the segment payload. ​ Close a connection the client TCP to send a special TCP segment to the server process. This special segment has a flag bit in the segment’s header, the FIN bit set to 1. When the server receives this segment, it sends the client an acknowledgment segment in return. The server then sends its own shutdown segment, which has the FIN bit set to 1. Finally, the client acknowledges the server’s shutdown segment. Congestion Control [网络中间及路由产生拥塞] The problem of “congestion” Scenario 1: Two Senders, a Router with Infinite Buffers 当发送速率接近于总吞吐量时，时延会疯狂上升 Scenario 2: Two Senders and a Router with Finite Buffers ​ 当发送速率上升， 总吞吐量上升缓慢 Scenario 3: Four Senders, Routers with Finite Buffers, and Multihop Paths ​ 会出现两条路相互竞争的现象 Approaches End-end congestion control (inferred from loss and delay)：the network layer provides no explicit support to the transport layer for congestion-control purposes. TCP takes this end-to-end approach toward congestion control Network-assisted congestion control (TCP ECN bit)：With network-assisted congestion control, routers provide explicit feedback to the sender and/or receiver regarding the congestion state of the network. This feedback may be as simple as a single bit indicating congestion at a link. Congestion Control Algorithm: AIMD 限制发送的流量： cwnd: 拥塞窗口（Congestion Control） rwnd：接收窗口（Flow Control） 如何感知路径上发送拥塞： the occurrence of either a timeout or the receipt of three duplicate ACKs from the receiver. 怎样确定发送的速率： TCP AIMD TCP slow start Additive Increase： Increase sending rate by 1 maximum segment size every RTT until loss detected（整个速率以次方增长） Multiplicative Decrease： TCP Reno: cut in half on triple duplcate ACKs TCP Tahoe: cut to 1 MSS on timeout Congestion avoidance Tahoe Tahoe是TCP的最早版本，其主要有三个算法去控制数据流和拥塞窗口。 Slow Start（慢启动） （ssthresh：slow start thresh，慢启动门限值） 当cwnd的值小于ssthresh时，TCP则处于slow start阶段，每收到一个ACK，cwnd的值就会加1。 仔细分析，其实慢启动并不慢，经过一个RTT的时间，cwnd的值就会变成原来的两倍，实为指数增长。 Congestion Avoidance（拥塞避免） 当cwnd的值超过ssthresh时，就会进入Congestion Avoidance阶段，在该阶段下，cwnd以线性方式增长，大约每经过一个RTT，cwnd的值就会加1 Fast Retransmit（快重传） 按照拥塞避免算法中cwnd的增长趋势，迟早会造成拥塞（一般通过是否丢包来判断是否发生了拥塞）。 如果中网络中发生了丢包，通过等待一个RTO时间后再进行重传，是非常耗时的，因为RTO通常设置得会比较大（避免伪重传：不必要的重传）。 快重传的思想是：只要发送方收到了三个重复的ACK（如果不了解三个重复ACK如何产生，请温故一下滑动窗口协议），就会立马重传，而不用等到RTO到达（如果没有3个重复的ACK而包丢失了，就只能超时重传）； 并且将ssthresh的值设置为当前cwnd的一半，而cwnd减为1，重回slow start阶段。 Reno 除了包含Tahoe的三个算法，Reno多了一个Fast Recovery（快速恢复）算法。 当收到三个重复的ACK或是超过了RTO时间且尚未收到某个数据包的ACK，Reno就会认为丢包了，并认定网络中发生了拥塞。 Reno会把当前的ssthresh的值设置为当前cwnd的一半，但是并不会回到slow start阶段，而是将cwnd设置为（更新后的）ssthresh+3MSS，之后cwnd呈线性增长。 "},"3 Network Layer/Network Layer.html":{"url":"3 Network Layer/Network Layer.html","title":"Network Layer","keywords":"","body":"Network Layer Functions: 1. Routing (control plane) 2. Fowarding (data plane) Architectures Traditional network: integrated control plane + data plane Software defined network (SDN): separated control plane + data plane Router Architecture Forwarding Table(最长匹配原则) Switching Fabrics Switching via memory： the overall forwarding throughput (the total rate at which packets are transferred from input ports to output ports) must be less than B/2. Note also that two packets cannot be forwarded at the same time, even if they have different destination ports, since only one memory read/write can be done at a time over the shared system bus. Switching via a bus： All output ports receive the packet, but only the port that matches the label will keep the packet. Switching via an interconnection network： Queuing Input port queuing Condition: switch fabric slower than input ports combined HOL blocking problem(线路前部堵塞问题)：a queued packet in an input queue must wait for transfer through the fabric (even though its output port is free) because it is blocked by another packet at the head of the line. Output port queuing Condition: when datagrams arrive from fabric faster than link transmission rate How much buffering? RTT: 平均往返时延 C：链路容量 N：端口数 Scheduling FCFS (FIFO)：先进先出 Priority scheduling Round Robin (RR) scheduling packets are sorted into classes as with priority queuing. However, rather than there being a strict service priority among classes, a round robin scheduler alternates service among the classes Weighted Fair Queuing (WFQ) ​ IP Datagram format Subnets device interfaces that can physically reach each other without passing through an intervening router IP addresses have structure: subnet part: devices in same subnet have common high order bits host part: remaining low order bits IP addressing: CIDR CIDR: Classless InterDomain Routing (pronounced “cider”) subnet portion of address of arbitrary length format: a.b.c.d/x, where x is #bits in subnet portion of address Dynamic Host Configuration Protocol (DHCP) Function DHCP allows a host to obtain (be allocated) an IP address automatically. Process DHCP server: typically co-located in router Network Address Translation (NAT) Motivation： just one IP address needed from provider ISP for all devices can change addresses of host in local network without notifying outside worl can change ISP without changing addresses of devices in local network security: devices inside local net not directly addressable, visible by outside world Principle all devices in local network share just one IPv4 address as far as outside world is concerned Process Generalized Forwarding in SDN Match + action match: pattern values in packet header fields actions: for matched packet: drop, forward, modify, matched packet or send matched packet to controller OpenFlow Routing Protocols Link State (LS)：Dijkstra algorithm 1 Initialization: 2 N' = {u} /* compute least cost path from u to all other nodes */ 3 for all nodes v 4 if v adjacent to u /* u initially knows direct-path-cost only to direct neighbors */ 5 then D(v) = cu,v /* but may not be minimum cost! 6 else D(v) = ∞ 7 8 Loop 9 find w not in N' such that D(w) is a minimum 10 add w to N' 11 update D(v) for all v adjacent to w and not in N' : 12 D(v) = min ( D(v), D(w) + cw,v ) 13 until all nodes in N' 需要输入一个source 和对应的表 shortcoming: 会出现线路拥堵程度的震荡 Distance Vector (DV)：Bellman-Ford algorithm cons: \"好事传播速度快，坏事传 Three classes of OpenFlow messages controller-to-switch switch-to-controller symmetric (misc.) "},"4 Link Layer/Link Layer.html":{"url":"4 Link Layer/Link Layer.html","title":"Link Layer","keywords":"","body":"Link Layer Responsibility: transferring datagram from one node to physically adjacent node over a link Datagrams: frames Different link protocols over different links Wired: Ethernet, token ring Wireless: WIFI, Bluetooth Network scope: LAN Error Detection/Correction Single bit parity 加一个检验比特，使得总共1的个数为偶数个，若检测到为奇数个则出错 只能检验出出错个数为奇数 Two-dimensional bit parity detect and correct single bit errors detect two bits errors, but cannot correct Cyclic Redundancy Check (CRC) D: data bits (given, think of these as a binary number) G: bit pattern (generator), of r+1 bits (given) 给定一个G和一个R，使得G可以整除 receiver knows G, divides by G. If non-zero remainder: error detected! can detect all burst errors less than r+1 bits widely used in practice (Ethernet, 802.11 WiFi) Multiple Access Protocols Collision Two or more simultaneous transmissions by nodes on a shared channel Collision domain Hosts that on a shared broadcast medium, where collisions may occur Taxonomy of MAC protocols Channel of partitioning (collision-free) TDMA, FDMA Random access (need to handle collisions) Slotted ALOHA 把时间分成时间间隙 When the node has a fresh frame to send, it waits until the beginning of the next slot and transmits the entire frame in the slot. If there isn’t a collision, the node has successfully transmitted its frame and thus need not consider retransmitting the frame. (The node can prepare a new frame for transmission, if it has one.) If there is a collision, the node detects the collision before the end of the slot. The node retransmits its frame in each subsequent slot with probability p until the frame is transmitted without a collision. ALOHA 没有将时间分成间隙，直接立即发送 CSMA/CD Listen before speaking. If someone else is speaking, wait until they are finished. In the networking world, this is called carrier sensing—a node listens to the channel before transmitting. If a frame from another node is currently being transmitted into the channel, a node then waits until it detects no transmissions for a short amount of time and then begins transmission. If someone else begins talking at the same time, stop talking. In the networking world, this is called collision detection—a transmitting node listens to the channel while it is transmitting. If it detects that another node is transmitting an interfering frame, it stops transmitting and waits a random amount of time before repeating the sense-and-transmit-when-idle cycle. Taking turns (collision free, with more flexibility but with overhead) Polling token pass LAN Addressing ARP: IP address => MAC address Self-learning mechanism Routing to another subnet Ethernet "}}